# This is a Work In Progress
name: Reusable Scalingo Postgresql Setup Workflow

# TODO Make postgre extentions a command to pass as input

on:
  workflow_call:
    inputs:
      application-full-name:
        required: true
        type: string

      #If using extentions => PostGIS extension requires at least a “Starter 512M” plan to work. (ref : https://doc.scalingo.com/databases/postgresql/extensions)
      addon-plan-postgresql:
        required: true
        type: string

      reference-application-name:
        required: false
        type: string

    outputs:
      target-database-url:
        description: "The application database url"
        value: ${{ jobs.get-database-url.outputs.target-database-url }}

    secrets:
      SCALINGO_API_TOKEN:
        required: true

jobs:
  addon-postgresql-with-extentions:
    name: Add the postgresql addon if not present
    runs-on: ubuntu-latest
    container:
      image: rcambonie/scalingo-cli

    steps:
      - name: Login with api-token
        run: scalingo login --api-token=${{ secrets.SCALINGO_API_TOKEN }}

      - name: check if addon exists
        id: postgresql-addon-exist
        run: |
          set +e
          POSTGRESQL_ADDON_EXIST=$(scalingo --app ${{ inputs.application-full-name }} addons | grep -c PostgreSQL)
          set -e
          echo $POSTGRESQL_ADDON_EXIST
          echo "::set-output name=postgresql-addon-exist::$POSTGRESQL_ADDON_EXIST"

      ## The if form with if [[ $VAR -eq NUMBER ]];
      #- name: Add the postgresql addon
      #  if: ${{ steps.postgresql-addon-exist.outputs.postgresql-addon-exist }} == 0
      #  run: if [[ ${{ steps.postgresql-addon-exist.outputs.postgresql-addon-exist }} -eq 0 ]]; then scalingo --app ${{ inputs.application-full-name }} addons-add postgresql ${{ inputs.addon-plan-postgresql }}; else echo 'addon exists already'; fi

      - name: Add the postgresql addon
        id: postgresql-addon-add
        if: steps.postgresql-addon-exist.outputs.postgresql-addon-exist == 0
        run: |
          scalingo --app ${{ inputs.application-full-name }} addons-add postgresql ${{ inputs.addon-plan-postgresql }}
          sleep 45
          echo 'I hope the postgresql addon is provisionned'

      # TODO : Still up-to-date ? : https://github.community/t/how-to-retry-a-failed-step-in-github-actions-workflow/125880
      - name: Add the postgresql addon extention (attempt 1/2)
        if: steps.postgresql-addon-add.outcome=='success' && steps.postgresql-addon-exist.outputs.postgresql-addon-exist == 0
        id: postgresql-addon-extentions-1
        timeout-minutes: 1
        continue-on-error: true
        run: |
          echo "CREATE extension postgis;" | scalingo --app ${{ inputs.application-full-name }} pgsql-console
          quit

      - name: Add the postgresql addon extention (attempt 2/2)
        if: steps.postgresql-addon-extentions-1.outcome=='failure'
        id: postgresql-addon-extentions-2
        timeout-minutes: 1
        continue-on-error: true
        run: |
          sleep 30
          echo "CREATE extension postgis;" | scalingo --app ${{ inputs.application-full-name }} pgsql-console
          quit

  # From one-off container (files changes to the container are not persisted)
  # https://doc.scalingo.com/platform/app/tasks
  restore-and-migrate-db:
    name: Dump and restore the production database to the feature app
    runs-on: ubuntu-latest
    needs:
      - addon-postgresql-with-extentions
    container:
      image: rcambonie/scalingo-cli

    steps:
      - name: Login with api-token
        run: scalingo login --api-token=${{ secrets.SCALINGO_API_TOKEN }}

      - name: Export the app database url string
        id: target-database-url
        run: |
          TARGET_DATABASE_URL=$(scalingo --app ${{ inputs.application-full-name }} env | grep SCALINGO_POSTGRESQL_URL=postgres://)
          echo $TARGET_DATABASE_URL
          TARGET_DATABASE_URL=${TARGET_DATABASE_URL//SCALINGO_POSTGRESQL_URL=/}
          echo $TARGET_DATABASE_URL
          echo "::set-output name=target-database-url::$TARGET_DATABASE_URL"

      # TODO Not sure if the pg command are right
      - name: Dump the reference application database and restore to the target database from dump
        if: ${{ inputs.application-full-name != inputs.reference-application-name }}
        run:
          scalingo --app ${{ inputs.reference-application-name }} run bash -c "dbclient-fetcher psql && \
          pg_dump --clean --if-exists --format c --no-owner --no-privileges --no-comments --exclude-schema 'information_schema' --exclude-schema '^pg_*' --dbname $DATABASE_URL --file dump.pgsql && \
          pg_restore --clean --if-exists --no-owner --no-privileges --no-comments --dbname ${{ steps.export-target-database-url.outputs.target-database-url }} --file dump.pgsql"

      # Need to remove package.json or else it gives and error trying to run in esm
      # TODO Find if we can we force the us of cjs ?
      # TODO Find an elegant way to get dependencies (jq or another job ?)
      # Was forced to add "ls && " at the start or else the npm command fails for an unknowable reason.
      - name: Run the missing migrations with node-pg-migrate
        run: scalingo --app ${{ inputs.application-full-name }} run bash -c "ls && npm install node-pg-migrate pg-format date-fns fs-extra ramda zod && ls && rm package.json && ls && DATABASE_URL=${{ steps.target-database-url.outputs.target-database-url }} node-pg-migrate up"
